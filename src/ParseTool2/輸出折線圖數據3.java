package ParseTool2;

import java.util.ArrayList;
import java.util.List;

import InputData.日線;
import InputData.簡單解析;
import InputData.計算目標;
import OutputData.折点;
import ParseTool.簡單解析Util;
import ParseTool.計算目標Util;
import ParseTool.輸出debug信息Util;
import common.CommonConst;

public class 輸出折線圖數據3 {

	public static void main(String[] args) {

		String[][] s =
			 {
				 {"20191010","12.02","11.96","12.04","11.91","27261229","326023328.00"},
				 {"20191011","12.05","12.45","12.45","12.00","92030800","1131441664.00"},
				 {"20191014","12.59","12.94","13.22","12.52","123970103","1596408960.00"},
				 {"20191015","12.95","13.09","13.14","12.86","73394591","952804800.00"},
				 {"20191016","13.08","13.08","13.33","12.90","67002223","876220992.00"},
				 {"20191017","13.07","13.17","13.25","13.03","47869313","628571136.00"},
				 {"20191018","13.24","12.78","13.29","12.72","64992896","840281792.00"},
				 {"20191021","12.80","12.91","13.03","12.75","38996287","502880224.00"},
				 {"20191022","13.03","12.93","13.05","12.77","31396257","404182688.00"},
				 {"20191023","12.89","12.86","12.95","12.77","32821414","422141024.00"},
				 {"20191024","12.98","13.09","13.24","12.95","103158806","1347032704.00"},
				 {"20191025","13.09","12.90","13.09","12.78","97876357","1260246528.00"},
				 {"20191028","12.75","12.70","12.88","12.65","72380466","919894912.00"},
				 {"20191029","12.74","12.77","12.85","12.62","52604090","669546624.00"},
				 {"20191030","12.75","12.59","12.79","12.52","53734730","678152768.00"},
				 {"20191031","12.68","12.51","12.70","12.50","33347533","419183008.00"},
				 {"20191101","12.50","12.75","12.83","12.44","62705733","793656960.00"},
				 {"20191104","12.75","12.74","12.89","12.69","49737996","634816384.00"},
				 {"20191105","12.74","12.95","13.19","12.69","74274389","962257408.00"},
				 {"20191106","12.95","12.92","13.10","12.86","46023920","597016896.00"},
				 {"20191107","12.95","12.76","12.95","12.71","46267281","592408768.00"},
				 {"20191108","12.80","12.57","12.81","12.56","48841866","617218176.00"},
				 {"20191111","12.48","12.29","12.48","12.29","38594267","477989504.00"},
				 {"20191112","12.31","12.24","12.36","12.17","39239395","480742752.00"},
				 {"20191113","12.21","12.23","12.29","12.15","32274979","394505184.00"},
				 {"20191114","12.23","12.14","12.27","12.10","28943647","351795392.00"},
				 {"20191115","12.22","12.15","12.26","12.12","27324299","332797312.00"},
				 {"20191118","12.17","12.24","12.35","12.13","28796529","352880160.00"},
				 {"20191119","12.20","12.23","12.31","12.18","29370803","359115488.00"},
				 {"20191120","12.17","12.04","12.22","12.01","38092059","460234688.00"},
				 {"20191121","12.00","11.96","12.04","11.91","34617175","414077536.00"},
				 {"20191122","12.01","11.99","12.06","11.94","29531099","354250528.00"},
				 {"20191125","12.03","12.07","12.14","12.00","25153256","303962336.00"},
				 {"20191126","12.15","12.06","12.17","11.98","59633264","719075392.00"},
				 {"20191127","12.07","11.99","12.07","11.90","28703956","343598880.00"},
				 {"20191128","12.00","11.96","12.01","11.92","17797225","212826176.00"},
				 {"20191129","11.93","11.91","12.07","11.89","24566935","293541792.00"},
				 {"20191202","11.96","11.87","11.97","11.82","22163020","263131792.00"},
				 {"20191203","11.81","11.86","11.90","11.77","19557865","231361392.00"},
				 {"20191204","11.78","11.75","11.83","11.70","24734662","290465760.00"},
				 {"20191205","11.79","11.89","11.89","11.76","24976130","295963968.00"},
				 {"20191206","11.92","11.92","11.95","11.83","20654438","245635920.00"},
				 {"20191209","11.90","11.90","11.93","11.85","17349258","206211632.00"},
				 {"20191210","11.88","11.86","11.91","11.86","15324640","181988688.00"},
				 {"20191211","11.88","11.98","11.99","11.85","33409045","398582368.00"},
				 {"20191212","11.99","11.90","11.99","11.88","27021203","321917920.00"},
				 {"20191213","11.98","12.12","12.12","11.94","59520554","716034816.00"},
				 {"20191216","12.12","12.13","12.15","12.00","37971632","458170272.00"},
				 {"20191217","12.17","12.39","12.51","12.10","57435605","707895680.00"},
				 {"20191218","12.36","12.40","12.50","12.34","34565268","428827232.00"},
				 {"20191219","12.40","12.41","12.50","12.38","23789907","295686656.00"},
				 {"20191220","12.41","12.42","12.55","12.38","40150148","500592352.00"},
				 {"20191223","12.46","12.20","12.46","12.17","37033891","455979040.00"},
				 {"20191224","12.21","12.28","12.29","12.20","21671029","265496464.00"},{"20191225","12.29","12.24","12.29","12.20","13678175","167407904.00"},{"20191226","12.26","12.29","12.32","12.23","15739054","193083040.00"},{"20191227","12.25","12.32","12.43","12.25","27932109","344832512.00"},{"20191230","12.27","12.34","12.36","12.12","41051555","503090496.00"},{"20191231","12.32","12.37","12.38","12.21","31953628","392736224.00"},{"20200102","12.47","12.47","12.64","12.45","51629079","647446144.00"},{"20200103","12.57","12.60","12.63","12.47","38018810","477053344.00"},{"20200106","12.52","12.46","12.65","12.42","41001193","514432544.00"},{"20200107","12.51","12.50","12.60","12.46","28421482","355811744.00"},{"20200108","12.41","12.32","12.45","12.25","35240536","434980256.00"},{"20200109","12.39","12.37","12.43","12.35","26151448","324168064.00"},{"20200110","12.37","12.39","12.42","12.31","18321252","226580304.00"},{"20200113","12.40","12.41","12.41","12.31","20715566","255982384.00"},{"20200114","12.40","12.43","12.69","12.39","29994561","374971648.00"},{"20200115","12.41","12.25","12.45","12.25","31897217","392531136.00"},{"20200116","12.28","12.20","12.31","12.16","22454876","274130144.00"},{"20200117","12.22","12.23","12.29","12.16","17593111","215028080.00"}};
				 輸出折線圖數據3 o = new 輸出折線圖數據3();
		List<折点> l = o.輸出折線圖數據2(s,3);
		l.size();
	}

	public List<折点> 輸出折線圖數據2(String[][] arrayList日線, int 對象個數) {
		List<日線> list日線 = new ArrayList();
		for(String[] array日線 : arrayList日線){

			// 0:
			// 1:
			// 2:
			// 3:
			// 4:

			list日線.add(new 日線(
					array日線[CommonConst.日時],
					array日線[CommonConst.開盤價],
					array日線[CommonConst.收盤價],
					array日線[3],
					array日線[4]
					));
		}


		計算目標 o計算目標 = new 計算目標();
		
		int index = 0 ;

		List<折点> list折点 = new ArrayList();

		輸出折線圖數據(o計算目標, list日線, index, 對象個數, list折点);

		return list折点;
	}
	
	計算目標Util 計算目標util =new 計算目標Util();

	public List<折点> 輸出折線圖數據(String[][] arrayList日線, int 對象個數) {
		List<日線> list日線 = new ArrayList();
		for(String[] array日線 : arrayList日線){

			// 0:
			// 1:
			// 2:
			// 3:
			// 4:

			list日線.add(new 日線(
					array日線[CommonConst.日時],
					array日線[CommonConst.開盤價],
					array日線[CommonConst.收盤價],
					array日線[CommonConst.最高價],
					array日線[CommonConst.最低價]
					));
		}


		計算目標 o計算目標 = new 計算目標();
		
		int index = 0 ;

		List<折点> list折点 = new ArrayList();

		輸出折線圖數據(o計算目標, list日線, index, 對象個數, list折点);

		return list折点;
	}

	private void 輸出折線圖數據( 計算目標 o計算目標, List<日線> list日線,int 假点index, int 對象個數, List<折点> list折点) {
//		一个区间内（假点，日线，index，對象個數）
//	       假点以后：做成處理对象（）
//	       判断：處理对象
//	       處理（處理对象）：更新假点，追加折点
//	       是否到了最后：无處理对象：返回
//	       遞歸調用自己：（假点，日線，index，對象個數）

		
		簡單解析 o簡單解析 = 做成處理对象(o計算目標, list日線, 假点index, 對象個數, CommonConst.A模式_取得新的区间);
		輸出debug信息Util.print(list折点, o計算目標, list日線, 假点index, o簡單解析, "A");
		
		int iResult = 判断(o簡單解析, o計算目標, list日線, 假点index);
		
		if(iResult == CommonConst.如果_這是最後一次計算) {
			最后一次计算(o計算目標, o簡單解析, list折点);
			return;
		}
		

		簡單解析 o簡單解析2 = 處理(iResult, o簡單解析, o計算目標, list日線, list折点);
		輸出debug信息Util.print(list折点, o計算目標, list日線, 假点index, o簡單解析2, "A");
		
		if(是否到了最后(o計算目標, list日線)) {
			最后一次计算(o計算目標, o簡單解析, list折点);
			return;
		}
		
		// 如果还有余點，出于一个区间有两个点的考虑，再找一次
		if(o計算目標.get假().get日時() < o簡單解析.get結束().get日時()) {
			輸出折線圖數據_B(o計算目標, list日線, o計算目標.get假().getIndex(), 對象個數, list折点);
		}

		//index = 簡單解析Util.取得指定日期的index(list日線, o計算目標.get假().get日時());
		假点index =  o計算目標.get假().getIndex();
		//index++;

		if(假点index == 19 ) {
			假点index = 19;
		}
		
//		if(最后一次计算(list日線, index)) {
//			return;
//		}
		
		輸出折線圖數據(o計算目標, list日線, 假点index, 對象個數,list折点);

	}
	
	
	
	private boolean 最后一次计算(List<日線> list日線, int index) {
		if(index == list日線.size()-1 ) {
			return true;
		}
		return false;
	}

	private void 輸出折線圖數據_B( 計算目標 o計算目標, List<日線> list日線,int 假点index, int 對象個數, List<折点> list折点) {		

		簡單解析 o簡單解析 = 做成處理对象(o計算目標, list日線, 假点index, 對象個數, CommonConst.B模式_有限区间内再找一点);

		輸出debug信息Util.print(list折点, o計算目標, list日線, 假点index, o簡單解析, "B");
		int iResult = 判断(o簡單解析, o計算目標, list日線, 假点index);
		
		if(iResult == CommonConst.如果_這是最後一次計算) {
			最后一次计算(o計算目標, o簡單解析, list折点);
			return;
		}
		

		簡單解析 o簡單解析2 = 處理(iResult, o簡單解析, o計算目標, list日線, list折点);
		
		輸出debug信息Util.print(list折点, o計算目標, list日線, 假点index, o簡單解析2, "B");

	}

	private void 最后一次计算(計算目標 o計算目標, 簡單解析 o簡單解析, List<折点> 折点list) {
		// 假点是否为日线的最后一个
		// 假点变确点
		計算目標util.追加假点(o計算目標, o簡單解析, 折点list);		
		
	}

	private boolean 是否到了最后(計算目標 o計算目標, List<日線> list日線) {
//		是否到了最后：
//	      假点是否为日线的最后一个

		int i最后一天日时 = Integer.parseInt(list日線.get(list日線.size()-1).get日時());

		if(i最后一天日时 == o計算目標.get假().get日時()) {
			return true;
		}
		return false;
	}

	private 簡單解析 處理(int iResult, 簡單解析 簡單解析對象, 計算目標 o計算目標, List<日線> list日線, List<折点> 折点list) {

		簡單解析 O處理對象 = 簡單解析對象;
		// 新假点的前2天，后2天再确认
		// 重新取得指定日的前后指定天数的最大最小值（簡單解析對象）
		if(iResult !=  CommonConst.如果_這是第一次計算 &&  簡單解析對象.getList指定数据().size() > 1 ) {
			if(o計算目標.get假().get日時() > 20191114) {
				iResult = iResult;
			}
			int index假点 = o計算目標.get假().getIndex();
			O處理對象 = new 簡單解析(簡單解析Util.取得指定日的前后指定天数的簡單解析(list日線, index假点, 簡單解析對象.getList指定数据().size(), o計算目標.get求高低()));
		}
		switch (iResult) {

		case CommonConst.如果_手持低点_要找高点_但碰见一个更低的谷:
			//1=如果  手持低点，要找高点，但碰见一个更低的谷
			// 更新假点
			計算目標util.更新假点(o計算目標, O處理對象, 折点list);
			break;

		case CommonConst.如果_手持低点_要找高点_但没有碰见一个更低的谷:
			//2=如果  手持低点，要找高点，但没有碰见一个更低的谷
			// 如果 碰見高點
			// 就，固定低点，假設高點，尋找下一個低點
			// 假点是否在簡單解析的对象中

			計算目標util.追加假点(o計算目標, O處理對象, 折点list);
			break;

		case CommonConst.如果_手持高点_要找底点_但碰见一个更高的谷:
			//3=如果  手持高点，要找底点，但碰见一个更高的谷
			// 更新假点
			計算目標util.更新假点(o計算目標, O處理對象, 折点list);
			break;

		case CommonConst.如果_手持高点_要找底点_但没碰见一个更高的谷:
			//4=如果  手持高点，要找底点，但没碰见一个更高的谷
			// 如果  碰見低點
			// 就，固定高点，假設低點，尋找下一個高點

			計算目標util.追加假点(o計算目標, O處理對象, 折点list);
			break;

		case CommonConst.如果_這是第一次計算:
			//5=如果  這是第一次計算（折点list為空）
			計算目標util.第一次计算(o計算目標, 簡單解析對象, 折点list);
			break;

		case CommonConst.如果_這是最後一次計算:
			//6=如果  這是最後一次計算（簡單解析结果的最后一条 ）
			計算目標util.最后一次计算(o計算目標, O處理對象, 折点list);
			break;
		}
		
		return O處理對象;

	}

	private int 判断(簡單解析 o簡單解析, 計算目標 o計算目標, List<日線> list日線, int index) {

//		判断：
//	      假点为空：第一次：追加确点，追加假点
//	      假点为高，求低，碰见更高：更新假点_高
//	      假点为高，求低，未碰见更高：追加新假点_高
//	      假点为低，求高，碰见更低：更新假点_低
//	      假点为低，求高，未碰见更低：追加新假点_低

		//5=如果  这是第一次计算（折点list為空 ）
		if(o計算目標.get假()==null)return CommonConst.如果_這是第一次計算;
		if(index >= list日線.size()-1 )
			return CommonConst.如果_這是最後一次計算;

		// 手持高低点:假是低还高
		int 假点高低点=o計算目標.get假().get高低();//0=低 1=高
		// 要找高低点:求是低还高
		int 求高低点=o計算目標.get求().get高低();//0=低 1=高
		// 下一个简单安区间的高低点(求=高，看簡單區間的低點；求=低，看簡單區間的高點)
		int 碰見更高低點=判断是否更高低(o簡單解析, o計算目標);


		//1=如果  手持低点，要找高点，但碰见一个更低的谷
		if(假点高低点==CommonConst.低点 && 求高低点==CommonConst.高点 && 碰見更高低點 == CommonConst.更低点) return CommonConst.如果_手持低点_要找高点_但碰见一个更低的谷;
		//2=如果  手持低点，要找高点，但没有碰见一个更低的谷
		if(假点高低点==CommonConst.低点 && 求高低点==CommonConst.高点 && 碰見更高低點 != CommonConst.更低点) return CommonConst.如果_手持低点_要找高点_但没有碰见一个更低的谷;
		//3=如果  手持高点，要找底点，但碰见一个更高的谷
		if(假点高低点==CommonConst.高点 && 求高低点==CommonConst.低点 && 碰見更高低點 == CommonConst.更高点) return CommonConst.如果_手持高点_要找底点_但碰见一个更高的谷;
		//4=如果  手持高点，要找底点，但没碰见一个更高的谷
		if(假点高低点==CommonConst.高点 && 求高低点==CommonConst.低点 && 碰見更高低點 != CommonConst.更高点) return CommonConst.如果_手持高点_要找底点_但没碰见一个更高的谷;

		if(是否到了最后(o計算目標, list日線)) return CommonConst.如果_這是最後一次計算;

		return 0;//啥也不是
	}

	private int 判断是否更高低(簡單解析 o簡單解析, 計算目標 o計算目標) {
		int 碰見更高低點=CommonConst.未超想象; //0=更低 1=更高


		Float f簡單解析最低 = Float.parseFloat(o簡單解析.get最低().get价格());
		Float f簡單解析最高 = Float.parseFloat(o簡單解析.get最高().get价格());
		Float f現在假點的價格 = Float.parseFloat(o計算目標.get假().get价格());

		if(o計算目標.get求高低() == CommonConst.高点) {
			if(f簡單解析最低 < f現在假點的價格) {
				碰見更高低點=CommonConst.更低点;
			}
		}
		if(o計算目標.get求高低() == CommonConst.低点) {
			if(f簡單解析最高 > f現在假點的價格) {
				碰見更高低點=CommonConst.更高点;
			}
		}
		return 碰見更高低點;
	}

	private 簡單解析 做成處理对象(計算目標 o計算目標, List<日線> list日線, int index, int 對象個數, int iType) {
//		做成處理对象
//	     如果假点为空，
//	             就是全对象（日线，index，對象個數）
//	     如果假点不为空，
//	             就是假点以后的对象
//	                  （日线，假点index，
//	                     對象個數 - 假点index - index）
		
		int 處理個數 = 對象個數;

		簡單解析 o簡單解析 = new 簡單解析();
		if(o計算目標.get假()==null) {
			o簡單解析 = 簡單解析Util.取得指定區間數據製作簡單解析(list日線,index, 對象個數);


		}

		if (o計算目標.get假() != null) {
			//int i假点index = 簡單解析Util.取得指定日期的index(list日線, o計算目標.get假().get日時());
			int i假点index = o計算目標.get假().getIndex();
			
			if( iType == CommonConst.A模式_取得新的区间) { // A模式：取得新的区间			
			
				if(i假点index + 1 + 對象個數 > list日線.size()-1) {
					處理個數 = list日線.size() -1 - i假点index;
				}
			
			}
			if( iType == CommonConst.B模式_有限区间内再找一点) { // B模式：有限区间内再找一点	
				if(i假点index + 1 + 對象個數 > list日線.size()-1) {
					處理個數 = list日線.size() -1  - i假点index;
				}else {
					處理個數 = index + 對象個數 - i假点index -1;
				}
			}
			
			o簡單解析 = 簡單解析Util.取得指定區間數據製作簡單解析2(list日線, i假点index, 處理個數);
		}
		
		
		return o簡單解析;
	}

	/*
一个区间内只有一个高低点

除非是单一属性：直下。直上。否则必有波动

问题在于：结合点的處理：只處理假点以后未识别的数据
理由：一个假点只代表一个高或低点。另一个点不应该被漏掉。


一个区间内（假点，日线，index，對象個數）
       假点以后：做成處理对象（）
       判断：處理对象
       處理（處理对象）：更新假点，追加折点
       是否到了最后：无處理对象：返回
       递归调用自己：（假点，日线，index，對象個數）

做成處理对象
     如果假点为空，
             就是全对象（日线，index，對象個數）
     如果假点不为空，
             就是假点以后的对象
                  （日线，假点index，
                     對象個數 - 假点index - index）

判断：
      假点为空：第一次：追加确点，追加假点
      假点为高，求低，碰见更高：更新假点_高
      假点为高，求低，未碰见更高：追加新假点_高
      假点为低，求高，碰见更低：更新假点_低
      假点为低，求高，未碰见更低：追加新假点_低


是否到了最后：
      假点是否为日线的最后一个


處理：
      更新假点_高：
              新假点为属性相同的最大点（處理对象内）
              假点向后推移。不增加折点

      追加新假点_高：增加新折点
      更新假点_低：新假点为更低。
      追加新假点_低：
              新假点为属性相反的最大点（處理对象内）

	 */
}
