package ParseTool;

import java.util.ArrayList;
import java.util.List;

import InputData.日线;
import InputData.简单解析;
import InputData.计算目标;
import OutputData.折点;
import common.CommonConst;

public class 输出折线图数据 {
	/*
	输出折线图数据
		入口  【日线List】
		出口  【简单解析List】								折点（日期，位置（SEHL），价格）
		处理内容
			先来个【简单解析】
				入口  【日线List】【指定日线数】
				出口  【简单解析List】
				处理内容

			初始化【计算目标】
				出口  【计算目标】

			再调用输出折点list
				入力  【简单解析List】【计算目标】=null 【折点list】=null
				出口  【折点list】
				处理内容

	 */
	List<折点> 输出折线图数据(List<日线> list日线) {

		List<折点> 折点List = null;

		int 指定日线数 = 3;

		List<简单解析> 简单解析List = 简单解析Util.parse(list日线, 指定日线数);
		计算目标Util util = new 计算目标Util();
		计算目标 o计算目标 = util.初始化(简单解析List.get(0));

		折点List = 输出折点list(简单解析List, o计算目标, 折点List);
		return 折点List;

	}

	private List<折点> 输出折点list(List<简单解析> 简单解析List, 计算目标 o计算目标, List<折点> 折点List) {
		List<折点> 折点list = new ArrayList();

		//逐次解析每个简单解析的节点
		int index = 0;
		for(简单解析 o简单解析:简单解析List) {

			输出折点list(index,o计算目标,简单解析List,折点list);
			index ++;
		}
		return 折点list;
	}

	private void 输出折点list(int index, 计算目标 o计算目标, List<简单解析> 简单解析List, List<折点> 折点list) {

		boolean is是否最后的简单解析 = 简单解析List.size()==index+1?true:false;
		// 返回要解析的状态

		switch(解析当前状态(o计算目标, 简单解析List.get(index),折点list,is是否最后的简单解析)) {
		case 1:
		//1=如果  手持低点，要找高点，但碰见一个更低的谷
		case 2:
		//2=如果  手持低点，要找高点，但没有碰见一个更低的谷
		case 3:
		//3=如果  手持高点，要找底点，但碰见一个更高的谷
		case 4:
		//4=如果  手持高点，要找底点，但没碰见一个更高的谷
		case 5:
		//5=如果  这是第一次计算（折点list为空 ）
		case 6:
		//6=如果  这是最后一次计算（简单解析结果的最后一条 ）
		}
	}


	private int 解析当前状态(计算目标 o计算目标, 简单解析 o简单解析, List<折点> 折点list, boolean is是否最后的简单解析) {

		//6=如果  这是最后一次计算（简单解析结果的最后一条 ）
		if(is是否最后的简单解析) return 6;

		//手持高低点:假是低还高
		int 手持高低点=o计算目标.get假().get高低();//0=低 1=高
		//要找高低点:求是低还高
		int 要找高低点=o计算目标.get求().get高低();//0=低 1=高
		// 下一个简单安区间的高低点(求=高，看简单区间的低点；求=低，看简单区间的高点)
		int 碰见更高低点=判断是都更高低(o简单解析, o计算目标);


		//1=如果  手持低点，要找高点，但碰见一个更低的谷
		if(手持高低点==CommonConst.低点 && 要找高低点==CommonConst.高点 && 碰见更高低点==CommonConst.更低点) return 1;
		//2=如果  手持低点，要找高点，但没有碰见一个更低的谷
		if(手持高低点==CommonConst.低点 && 要找高低点==CommonConst.高点 && 碰见更高低点!=CommonConst.更低点) return 2;
		//3=如果  手持高点，要找底点，但碰见一个更高的谷
		if(手持高低点==CommonConst.高点 && 要找高低点==CommonConst.低点 && 碰见更高低点==CommonConst.更高点) return 3;
		//4=如果  手持高点，要找底点，但没碰见一个更高的谷
		if(手持高低点==CommonConst.高点 && 要找高低点==CommonConst.低点 && 碰见更高低点==CommonConst.更高点) return 4;
		//5=如果  这是第一次计算（折点list为空 ）
		if(折点list.isEmpty())return 5;


		return 0;//啥也不是
	}

	private int 判断是都更高低(简单解析 o简单解析, 计算目标 o计算目标) {
		int 碰见更高低点=CommonConst.未超想象; //0=更低 1=更高

		Float f简单解析最低 = Float.parseFloat(o简单解析.get最低().get价格());
		Float f简单解析最高 = Float.parseFloat(o简单解析.get最高().get价格());
		Float f2 = Float.parseFloat(o计算目标.get假().get价格());

		if(o计算目标.get求().get高低() == CommonConst.高点) {
			if(f简单解析最低 < f2) {
				碰见更高低点=CommonConst.更低点;
			}
		}
		if(o计算目标.get求().get高低() == CommonConst.低点) {
			if(f简单解析最低 > f2) {
				碰见更高低点=CommonConst.更高点;
			}
		}
		return 碰见更高低点;
	}

//		简单解析 ＝ 【简单解析List】的开始点
//		p12 =【计算目标】．假
//		p13 =【计算目标】．求							有明确的高低，但无价格
//		p14 = 新
//
//
//		如果  手持低点，要找高点，但碰见一个更低的谷														（【计算目标】．求高低 = 高  and   简单解析。最低 小于 p12。价格）
//
//				p12 = 【简单解析。最低】
//
//		如果  手持低点，要找高点，但没有碰见一个更低的谷
//				如果 碰见高点
//					就，固定低点，假设高点，寻找下一个低点
//						固定低点（p12 .状态 = 确，追加确定折点：折点list。追加（p12））
//						假设高点（p13 .状态 = 假  p13 .日期 = yymmdd  p13 .位置 = H   p13 .价格 = H）
//						寻找下一个低点（新增折点p14，p14 .状态 = 求    p14 .高低 = 底）
//
//		如果  手持高点，要找底点，但碰见一个更高的谷														（【计算目标】．求高低 = 底  and   简单解析。最高   大于  p12。价格）
//
//				p12 = 【简单解析。最高】
//
//		如果  手持高点，要找底点，但没碰见一个更高的谷														（【计算目标】．求高低 = 底  and   简单解析。最高   大于 【计算目标。假定价格】）
//				如果 碰见低点
//					就，固定高点，假设低点，寻找下一个高点
//						固定低点（p12 .状态 = 确，追加确定折点：折点list。追加（p12））
//						假设高点（p13 .状态 = 假  p13 .日期 = yymmdd  p13 .位置 = H   p13 .价格 = H）
//						寻找下一个低点（新增折点p14，p14 .状态 = 求    p14 .高低 = 底）
//
//		如果	这是第一次计算					（折点list为空 ）
//				初始化【计算目标】
//					设定初始点
//						p1 .状态=确
//						p1 .日期 = yymmdd
//						p1 .位置 = S
//						p1 .格 = 价格
//						p1 .高低 = 高-低
//
//					设定假设点
//						p2 .状态=假							说明：p2是第一个碰到的【极致】点（高或低）就看哪个先出现
//						p2 .日期 = yymmdd
//						p2 .位置 = S
//						p2 .格 = 价格
//						p2 .高低 = 高-低
//
//					设定需求点
//						p3 .状态=求
//						p3 .日期 = 未知
//						p3 .位置 = 未知
//						p3 .格 = 未知
//						p3 .高低 = 高-低
//
//				【计算目标】。设置【确】信息
//				【计算目标】。设置【假】信息
//						根据【确】信息设置需求信息（尚不知道【假设】信息，只能利用【确】信息取得、）
//						设置		求高低
//								确定高低
//								确定价格
//				【计算目标】。设置【求】信息
//				【计算目标】。设置求高低
//
//				新增折点p1（追加确定折点：折点list。追加（p1））
//
//		如果		这是最后一次计算					（简单解析结果的最后一条 ）
//			求高
//				最后一点  小于 假的值
//					假的点 = 最后一点（日期、价格，位置，高低=低）
//					假的点确定，追加折点
//				最后一点  大于 假的点
//					假的点确定，追加折点
//					求的点 = 最后一点（日期、价格，位置，高低=高），追加折点
//
//			求低
//				最后一点  小于 假的值
//					假的点确定，追加折点
//					求的点 = 最后一点（日期、价格，位置，高低=低），追加折点
//
//				最后一点  大于 假的点
//					假的点 = 最后一点（日期、价格，位置，高低=高）
//					假的点确定，追加折点

}